function [east_label, ...          west_label]   = auto_block_label(seg_srtpt_long, ...                                           seg_srtpt_lat, ...                                           seg_endpt_long, ...                                           seg_endpt_lat, ...                                           snames)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                                                                      %%%%  auto_block_label.m                                                  %%%%                                                                      %%%%  MATLAB script                                                       %%%%                                                                      %%%%  automatically find closed blocks and assign integer labels          %%%%                                                                      %%%%                                                                      %%%%  This works by finding all fault segments that bound a given block.  %%%%  One segment is arbitrarily selected as a starting point.  With      %%%%  this first segment we pick one endpoint as the start of an          %%%%  ordered vertex vector.  We then search through the remaining        %%%%  segments for a segment with a common point.  Once this segment is   %%%%  identified the point not in common with the previous segment is     %%%%  added to the ordered index vector.  This process is continued       %%%%  until the starting point has been reached.                          %%%%                                                                      %%%%  The trick in all of this is to deal with branches such that we      %%%%  insure that we are not selecting blocks with smaller blocks         %%%%  in them.  To beat this problem we adopt a left hand rule.  That     %%%%  is, whenever an intersection is reached we will follow the branch   %%%%  to the left.                                                        %%%%                                                                      %%%%  Input arguments:                                                    %%%%     seg_srtpt_long,  fault segment start points (longitude)          %%%%     seg_srtpt_lat,   fault segment start points (latitude)           %%%%     seg_endpt_long,  fault segment end points (longitude)            %%%%     seg_endpt_lat,   fault segment end points (latitude)             %%%%                                                                      %%%%  Returned variables:                                                 %%%%     n_blocks,     total number of blocks                             %%%%     n_seg,        total number of declared fault segments            %%%%     east_label,   label of block bounding segment to the east        %%%%     west_label,   label of block bounding segment to the west        %%%%     snames,       names of fault segments                            %%%%                                                                      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%disp('--> Assigning block labels')%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Conformally project fault segment  %%%%  geometry into Cartesian space      %%%%  We do this by just a linear        %%%%  "unrolling" of longitude and       %%%%  latitude.  No obvious need for     %%%%  anything more.                     %%%%  Transpose it just for combining    %%%%  vectors later.                     %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%seg_srtpt_x                = seg_srtpt_long(:)';seg_srtpt_y                = seg_srtpt_lat(:)';seg_endpt_x                = seg_endpt_long(:)';seg_endpt_y                = seg_endpt_lat(:)';%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Get total number of segments and declare bounding block vectors  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%n_seg                      = numel(seg_srtpt_x);% disp(n_seg)seg_eb                     = zeros(n_seg, 1);seg_wb                     = zeros(n_seg, 1);% pause(3)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Make sure that                               %%%%  seg_srtpt_x ~= seg_endpt_x AND               %%%%  seg_srtpt_y ~= seg_endpt_y                   %%%%                                               %%%%  If not then add 'fuzz' to fix it.  The fuzz  %%%%  is a perturbation to the endpoint of         %%%%  10 meters.                                   %%%%                                               %%%%  This fails for the very rare case where      %%%%  adding fuzz in one case causes degeneracy    %%%%  somewhere else.  If this happens just        %%%%  change fuzz_size a little bit.               %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%fuzz_size                  = 0.01;%for seg_cnt = 1 : n_seg%    if (seg_srtpt_x(seg_cnt) == seg_endpt_x(seg_cnt))%       disp(sprintf('Found vertical segment : %s', snames(seg_cnt, :)))%       cmn_srt_x           = find(seg_srtpt_x == seg_srtpt_x(seg_cnt));%       cmn_srt_y           = find(seg_srtpt_y == seg_srtpt_y(seg_cnt));%       cmn_srt_idx         = intersect(cmn_srt_x, cmn_srt_y); %       cmn_end_x           = find(seg_endpt_x == seg_srtpt_x(seg_cnt));%       cmn_end_y           = find(seg_endpt_y == seg_srtpt_y(seg_cnt));%       cmn_end_idx         = intersect(cmn_end_x, cmn_end_y);%       seg_srtpt_x(cmn_srt_idx) = seg_srtpt_x(cmn_srt_idx) + fuzz_size;%       seg_endpt_x(cmn_end_idx) = seg_endpt_x(cmn_end_idx) + fuzz_size;%       %%  disp(strcat('Adding_fuzz_to: ',snames([cmn_srt_x, cmn_end_x], :)))%    end%end%clear seg_cnt fuzz_size cmn_srt_x cmn_end_x cmn_srt_y cmn_end_y%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Make sure that                               %%%%  seg_srtpt_x < seg_endpt_x                    %%%%                                               %%%%  If not then rename to fix it.                %%%%                                               %%%%  This may cause sign problems if used in the  %%%%  southern hemisphere of if used near the      %%%%  Greenwich meridian.                          %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%for seg_cnt = 1 : n_seg    if (seg_srtpt_x(seg_cnt) > seg_endpt_x(seg_cnt))       disp(sprintf('Reordering endpoints, segment : %s', snames(seg_cnt, :)))       temp_x               = seg_srtpt_x(seg_cnt);       seg_srtpt_x(seg_cnt) = seg_endpt_x(seg_cnt);       seg_endpt_x(seg_cnt) = temp_x;       temp_y               = seg_srtpt_y(seg_cnt);       seg_srtpt_y(seg_cnt) = seg_endpt_y(seg_cnt);       seg_endpt_y(seg_cnt) = temp_y;    endendclear seg_cnt temp_x temp_y%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Try the standard lon lat ordering scheme  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%[seg_srtpt_x, seg_srtpt_y, seg_endpt_x, seg_endpt_y] = order_lon_lat_pairs(seg_srtpt_x, seg_srtpt_y, seg_endpt_x, seg_endpt_y);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Check that all things are probably good  %%%%  by making sure that there are no single  %%%%  occurances of coordinates                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%temp_vec_x                 = unique([seg_srtpt_x, seg_endpt_x]);%temp_vec_y                 = unique([seg_srtpt_y, seg_endpt_y]);%fail_cnt                   = 0;%% for g_cnt = 1 : numel(temp_vec_x)%    f_x                    = find([seg_srtpt_x, seg_endpt_x] == temp_vec_x(g_cnt));%    f_y                    = find([seg_srtpt_y, seg_endpt_y] == temp_vec_y(g_cnt));   %    if (length(f_x) == 1 | length(f_y) == 1)%       disp('*** All blocks are not closed! ***')%       fail_cnt            = fail_cnt + 1;%    end% end%% if (fail_cnt == 0)%    disp('No hanging segments found')% endallc 								= [seg_srtpt_x(:) seg_srtpt_y(:);seg_endpt_x(:) seg_endpt_y(:)];[cou, i1]					 	= unique(allc, 'rows', 'first');[cou, i2]						= unique(allc, 'rows', 'last');if length(find((i2-i1)==0)) > 0;	fprintf(1, '*** All blocks are not closed! ***');else	fprintf(1, 'No hanging segments found');endclear temp_vec_x temp_vec_y fail_cnt g_cnt f_x f_y allc cou i1 i2%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Declare array to store polygon segment indices  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%seg_poly_ver               = zeros(n_seg, n_seg);%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  For each fault segment find left handed block  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%for s_cnt = 1 : n_seg   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   %%  Grab first fault segment  %%   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   crnt_idx                   = s_cnt;   crntpt_x                   = seg_srtpt_x(crnt_idx);   crntpt_y                   = seg_srtpt_y(crnt_idx);   srt_idx                    = crnt_idx;   seg_cnt                    = 1;   clear poly_vec   while 1      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      %%  Match endpoint to new start point  %%      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      srtpt_match_idx_x       = find(seg_srtpt_x == crntpt_x);      endpt_match_idx_x       = find(seg_endpt_x == crntpt_x);      srtpt_match_idx_y       = find(seg_srtpt_y == crntpt_y);      endpt_match_idx_y       = find(seg_endpt_y == crntpt_y);      new_match_idx_temp      = intersect([srtpt_match_idx_x, ...                                           endpt_match_idx_x], ...                                          [srtpt_match_idx_y, ...                                           endpt_match_idx_y]);      new_match_idx           = new_match_idx_temp(find(new_match_idx_temp~=crnt_idx));      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      %%  Make sure it is worthwhile to continue  %%      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      if (length(new_match_idx) == 0)         disp('***  No_connecting segment found!  Exiting! ***')         break;      end            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      %%  Deal with picking correct branch here  %%      %%  This will reduce new_match_idx to a    %%      %%  single element.                        %%      %%  Left hand rule at this point           %%      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      if (length(new_match_idx) > 1)         %%  disp('Picking branch')	 	 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	 %%  Calculate segment azimuths relative to look direction  %%	 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	          clear az_vec seg_az	 for a_cnt = 1 : length(new_match_idx)	    if (crntpt_x ~= seg_srtpt_x(new_match_idx(a_cnt)))	       seg_az(a_cnt)  =  atan2(seg_endpt_y(new_match_idx(a_cnt)) - ...                                       seg_srtpt_y(new_match_idx(a_cnt)) , ...                                       seg_endpt_x(new_match_idx(a_cnt)) - ...                                       seg_srtpt_x(new_match_idx(a_cnt)));	    else	       seg_az(a_cnt)  =  atan2(seg_srtpt_y(new_match_idx(a_cnt)) - ...                                       seg_endpt_y(new_match_idx(a_cnt)) , ...                                       seg_srtpt_x(new_match_idx(a_cnt)) - ...                                       seg_endpt_x(new_match_idx(a_cnt)));	    end	                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%            %%  Change azimuth from -pi to pi range to 0 to 2*pi range  %%            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%            if(seg_az(a_cnt) < 0)	       seg_az(a_cnt)         = seg_az(a_cnt) + (2 * pi);            end 	    	 end	 clear a_cnt         if (crntpt_x ~= seg_srtpt_x(crnt_idx))	    crnt_seg_az     = atan2(seg_endpt_y(crnt_idx) - ...                                    seg_srtpt_y(crnt_idx) , ...                                    seg_endpt_x(crnt_idx) - ...                                    seg_srtpt_x(crnt_idx));	 else	    crnt_seg_az     = atan2(seg_srtpt_y(crnt_idx) - ...                                    seg_endpt_y(crnt_idx) , ...                                    seg_srtpt_x(crnt_idx) - ...                                    seg_endpt_x(crnt_idx));	 end                  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%         %%  Change azimuth from -pi to pi range to 0 to 2*pi range  %%         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%         if(crnt_seg_az < 0)            crnt_seg_az       = crnt_seg_az + (2 * pi);         end	 	 	 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	 %%  Calculate relative angles between segments  %%	 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%         az_vec             = crnt_seg_az - seg_az;	          %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%          %%  Find smallest positive angle or if all values are  %%         %%  negative then take the value with the largest      %%         %%  magnitude.                                         %%         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%         if (length(az_vec) == length(find(az_vec < 0)))            [min_val, b_idx]   = min(az_vec);         else            az_vec(find(az_vec < 0))  = 9999;            [min_val, b_idx]   = min(az_vec);         end	          %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%         %%  Finally reduce new_match_idx to just the correct index  %%         %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%         new_match_idx         = new_match_idx(b_idx);      end      clear az_vec b_cnt min_val b_idx                  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      %%  Find endpoint and assign as new start point  %%      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      if (crntpt_x == seg_srtpt_x(new_match_idx) & ...          crntpt_y == seg_srtpt_y(new_match_idx))         crntpt_x             = seg_endpt_x(new_match_idx);         crntpt_y             = seg_endpt_y(new_match_idx);         crnt_idx             = new_match_idx;      else         crntpt_x             = seg_srtpt_x(new_match_idx);         crntpt_y             = seg_srtpt_y(new_match_idx);         crnt_idx             = new_match_idx;      end      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      %%  Break if all segments have been covered and  %%      %%  block is still not closed.  This finds       %%      %%  input errors and prevents infinite loops.    %%      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      if (seg_cnt > n_seg)         %%  disp(strcat('Cannot close block starting with segment ', num2str(srt_idx)))         disp(sprintf('Cannot close block starting with segment : %s', snames(srt_idx)))	 break;      end            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      %%  Break if we return to starting segment  %%      %%  Check segment indices                   %%      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      if (crnt_idx == srt_idx & seg_cnt > 1)%          disp(sprintf('Closed %s : bounded by %d segments', snames(s_cnt, :), seg_cnt))         seg_cnt              = 1;         poly_vec             = [poly_vec, srt_idx];         break;      else         poly_vec(seg_cnt)    = crnt_idx;         seg_cnt              = seg_cnt + 1;      end   end   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   %%  Put poly_vec into seg_poly_ver                     %%   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   seg_poly_ver(s_cnt, 1:length(poly_vec)) = sort(poly_vec);end%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Do a little bit of cleaning up  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%clear seg_cnt crnt_idx crnt_seg_az crntpt_x crntpt_y;clear endpt_match_idx_x endpt_match_idx_y new_match_idx;clear new_match_idx_temp poly_vec s_cnt seg_az;clear seg_cnt srtpt_match_idx_x srtpt_match_idx_y;%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Find unique segment sequences  %%%%  -or- make it such that every   %%%%  row of seg_poly_ver is         %%%%  unique.                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% disp('Determining unique block boundaries.')seg_poly_ver            = unique(seg_poly_ver, 'rows');%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Assign two block labels to each fault segment  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% disp('Finding bounding blocks for each segment.')[n_blocks, trash]              = size(seg_poly_ver);clear trash;for s_cnt = 1 : n_seg   clear b_tog;   for b_cnt = 1 : n_blocks      if (length(find(seg_poly_ver(b_cnt, :) == s_cnt)) == 1)         b_tog(b_cnt)          = 1;      else         b_tog(b_cnt)          = 0;      end   end   temp_b                      = find(b_tog == 1);   if (length(temp_b) ~= 2)      disp(strcat('Segment_', ...                  num2str(s_cnt), ...                  '_appears_to_be_bounded_by_', ...                  num2str(length(temp_b)), ...                  '_blocks!'))   else      seg_eb(s_cnt)            = temp_b(1);      seg_wb(s_cnt)            = temp_b(2);   endendclear s_cnt b_cnt temp_b b_tog%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Calculate the area of each block.  This is required    %%%%  to identify the exterior (largest) block for labeling  %%%%  (east-west) purposes.  It may also be useful to        %%%%  define the largest block as a fixed reference block.   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% disp('Identifying exterior block.')for b_cnt = 1 : n_blocks   bound_idx_1                 = find(seg_eb == b_cnt);   bound_idx_2                 = find(seg_wb == b_cnt);   bound_idx                   = sort([bound_idx_1 ; bound_idx_2]);   %%%%%%%%%%%%%%%%%%%%%%%%%%   %%  Grab first segment  %%   %%%%%%%%%%%%%%%%%%%%%%%%%%   crnt_idx                    = bound_idx(1);   crntpt_x                    = seg_srtpt_x(crnt_idx);   crntpt_y                    = seg_srtpt_y(crnt_idx);      for g_cnt = 1 : length(bound_idx)      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      %%  Store current vertices for calculating area later  %%      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      temp_crnt_x(g_cnt)      = crntpt_x;      temp_crnt_y(g_cnt)      = crntpt_y;            %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      %%  Calculate area of block  %%      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      if (g_cnt == length(bound_idx))         poly_area(b_cnt)          = polyarea(temp_crnt_x, ...                                              temp_crnt_y);      end                 %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      %%  Match endpoint to new start point  %%      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      srtpt_match_idx_x       = find(seg_srtpt_x(bound_idx) == crntpt_x);      endpt_match_idx_x       = find(seg_endpt_x(bound_idx) == crntpt_x);      srtpt_match_idx_y       = find(seg_srtpt_y(bound_idx) == crntpt_y);      endpt_match_idx_y       = find(seg_endpt_y(bound_idx) == crntpt_y);      new_match_idx_temp      = intersect([srtpt_match_idx_x , ...                                           endpt_match_idx_x] , ...                                          [srtpt_match_idx_y , ...                                           endpt_match_idx_y]);      new_match_idx           = new_match_idx_temp(find(bound_idx(new_match_idx_temp)~=crnt_idx));            if (crntpt_x == seg_srtpt_x(bound_idx(new_match_idx)) & ...          crntpt_y == seg_srtpt_y(bound_idx(new_match_idx)))         crntpt_x             = seg_endpt_x(bound_idx(new_match_idx));         crntpt_y             = seg_endpt_y(bound_idx(new_match_idx));         crnt_idx             = bound_idx(new_match_idx);      else         crntpt_x             = seg_srtpt_x(bound_idx(new_match_idx));         crntpt_y             = seg_srtpt_y(bound_idx(new_match_idx));         crnt_idx             = bound_idx(new_match_idx);      end   end   clear temp_crnt_x temp_crnt_yendclear b_cnt bound_idx_1 bound_idx_2 bound_idx crnt_idxclear crntpt_x crntpt_y g_cnt temp_crnt_x temp_crnt_yclear srtpt_match_idx_x srtpt_match_idx_y endpt_match_idx_x endpt_match_idx_yclear new_match_idx_temp new_match_idx%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Declare the largest block to be the exterior block.  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%[trash, big_poly_idx]         = max(poly_area);clear trash poly_area%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Now we must put the block labels on either the east  %%%%  or west side of each fault segment.  Thus far they   %%%%  Have been arbitrarily assigned.  To do this we will  %%%%  walk around each block (left hand rule again) so     %%%%  that we know that the current block label is always  %%%%  the 'interior' block that we are dealing with.       %%%%  Of course this does not hold for the exterior        %%%%  block.                                               %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% disp('Sorting block labels by east and west')west_label                     = zeros(1, length(seg_wb));east_label                     = zeros(1, length(seg_eb));for b_cnt = 1 : n_blocks   bound_idx_1                 = find(seg_eb == b_cnt);   bound_idx_2                 = find(seg_wb == b_cnt);   bound_idx                   = sort([bound_idx_1 ; bound_idx_2]);   %%%%%%%%%%%%%%%%%%%%%%%%%%   %%  Grab first segment  %%   %%%%%%%%%%%%%%%%%%%%%%%%%%   crnt_idx                    = bound_idx(1);   crntpt_x                    = seg_srtpt_x(crnt_idx);   crntpt_y                    = seg_srtpt_y(crnt_idx);      for g_cnt = 1 : length(bound_idx)      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      %%  Calculate azimuth relative to look angle  %%      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      if (crntpt_x ~= seg_srtpt_x(crnt_idx))	   crnt_seg_az     = atan2(seg_endpt_y(crnt_idx) - ...                                   seg_srtpt_y(crnt_idx) , ...                                   seg_endpt_x(crnt_idx) - ...                                   seg_srtpt_x(crnt_idx));      else           crnt_seg_az     = atan2(seg_srtpt_y(crnt_idx) - ...                                   seg_endpt_y(crnt_idx) , ...                                   seg_srtpt_x(crnt_idx) - ...                                   seg_endpt_x(crnt_idx));      end                  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      %%  Change azimuth from -pi to pi range to 0 to 2*pi range  %%      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      if(crnt_seg_az < 0)	 crnt_seg_az       = crnt_seg_az + (2 * pi);      end                  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      %%  Conditionally assign labels to east or west.  %%      %%  Check for exterior block too.                 %%      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      if (b_cnt == big_poly_idx)	 if (crnt_seg_az > 0 & crnt_seg_az <= pi)            west_label(crnt_idx)     = b_cnt;            if (b_cnt == seg_eb(crnt_idx))	       east_label(crnt_idx)  = seg_wb(crnt_idx);            else               east_label(crnt_idx)  = seg_eb(crnt_idx);            end         else            east_label(crnt_idx)     = b_cnt;            if (b_cnt == seg_eb(crnt_idx))	       west_label(crnt_idx)  = seg_wb(crnt_idx);            else               west_label(crnt_idx)  = seg_eb(crnt_idx);            end	          end      else	 if (crnt_seg_az > 0 & crnt_seg_az <= pi)            east_label(crnt_idx)     = b_cnt;            if (b_cnt == seg_eb(crnt_idx))	       west_label(crnt_idx)  = seg_wb(crnt_idx);            else               west_label(crnt_idx)  = seg_eb(crnt_idx);            end         else            west_label(crnt_idx)     = b_cnt;            if (b_cnt == seg_eb(crnt_idx))	       east_label(crnt_idx)  = seg_wb(crnt_idx);            else               east_label(crnt_idx)  = seg_eb(crnt_idx);            end	          end      end                  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      %%  Match endpoint to new start point  %%      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%      srtpt_match_idx_x       = find(seg_srtpt_x(bound_idx) == crntpt_x);      endpt_match_idx_x       = find(seg_endpt_x(bound_idx) == crntpt_x);      srtpt_match_idx_y       = find(seg_srtpt_y(bound_idx) == crntpt_y);      endpt_match_idx_y       = find(seg_endpt_y(bound_idx) == crntpt_y);      new_match_idx_temp      = intersect([srtpt_match_idx_x , ...                                           endpt_match_idx_x] , ...                                          [srtpt_match_idx_y , ...                                           endpt_match_idx_y]);      new_match_idx           = new_match_idx_temp(find(bound_idx(new_match_idx_temp)~=crnt_idx));            if (crntpt_x == seg_srtpt_x(bound_idx(new_match_idx)) & ...          crntpt_y == seg_srtpt_y(bound_idx(new_match_idx)))         crntpt_x             = seg_endpt_x(bound_idx(new_match_idx));         crntpt_y             = seg_endpt_y(bound_idx(new_match_idx));         crnt_idx             = bound_idx(new_match_idx);      else         crntpt_x             = seg_srtpt_x(bound_idx(new_match_idx));         crntpt_y             = seg_srtpt_y(bound_idx(new_match_idx));         crnt_idx             = bound_idx(new_match_idx);      end   endend%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Report bounding blocks  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% numel(west_label)% pause(3)for s_cnt = 1 : n_seg%    disp(sprintf('%s bounded by blocks %d and %d', snames(s_cnt, :), west_label(s_cnt), east_label(s_cnt)))end% numel(west_label)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Show the differences in the sorted and unsorted  %%%%  block label vectors                              %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  west_label                     = seg_wb(:)';%%  east_label                     = seg_eb(:)';%%%%%%%%%%%%%%%%%%%%%%%%%%  One last cleanup  %%%%%%%%%%%%%%%%%%%%%%%%%%% clear b_cnt bound_idx_1 bound_idx_2 bound_idx crnt_idx% clear crntpt_x crntpt_y g_cnt seg_eb seg_wb% clear srtpt_match_idx_x srtpt_match_idx_y endpt_match_idx_x endpt_match_idx_y% clear new_match_idx_temp new_match_idx% clear big_poly_idx crnt_seg_az seg_endpt_x seg_endpt_y% clear seg_poly_ver seg_srtpt_x seg_srtpt_y srt_idx%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  Acknowledge reaching the end of the function  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% disp('<-- Done assigning block labels')% disp(' ')